For 0.5.2:
o) Test error handling in epoll.
o) Test error handling with port(3C).
o) Condition variables to suppport spontaneous output from XCodecEncoderPipe.
o) Make UnixClient and UnixServer take the SocketType as an argument to make
   it possible to support both stream-orientation and datagram-orientation?
   Would need to update UnixServer's API to support both models.
o) Something higher-level than Pipe which supports various disciplines and
   makes it easier to write stream processing modules.
o) Add XCodec Pipes.
o) New look-ahead decoder that can handle yield hash requests and out-of-window
   definitions.

For 0.5.3:
o) Move to the getrusage-based Timer class and make it clear that that is what
   it is for.  Perhaps create a Timer base class and a UserTimer and WallTimer
   for real use?
o) Add a flush token for Pipe::input() ?
o) Add a flesh Event type for Pipe::output() ?
   XXX It's unclear, but I think a flush method or similar may be needed to
       implement buffer limiting?  A flush method being like input(), except
       that it only returns once the last Pipe in the Pipeline has returned
       flush complete, or error if data cannot be flushed because there is not
       enough to finish processing the data that is pending, at which point
       you at least know that everything else has been flushed?
o) Make Pipe::input take a parameter to send EOS along with data.

For 0.6.0:
o) Remove the xor_ from XCodecHash and just use Adler64::operator+=.  The xor
   doesn't overwhelmingly change the collision characteristics and costs quite
   a bit.  Just make the lower 32-bits of the hash the Adler64 values mixed
   and the upper 32-bits the mixed UUID associated with this XCodecCache.
   (See xcodec/FUTURE for more on UUIDs.)
o) Make interface/listener objects automatically start listening.
o) Clean up address configuration objects to be more sensible, being either
   specific components of addresses (e.g. to specify an IP address) or socket
   addresses (e.g. AF_UNIX paths, IP+port pairs for TCP or UDP or SCTP.)
o) Connector abstraction: connection pooling / connecting via a SOCKS server.

For 0.7.0:
o) Do some information exchange out-of-band when setting up connections between
   WANProxy instances so we know what Channel to send requests for declarations
   on.

For 0.8.0:
o) Cache hierarchy, including persistent storage.
o) TLS.

After 1.0.0:
o) A CLI program for management.  Remember to USE_POLL=select since Mac OS X can
   only use select(2) for stdin and stdout.
o) Make it possible to detect when we are sending to a socket that is also
   within WANProxy and avoid a system call -- just copy directly to the
   appropriate buffer.  It should be pretty easy to do this with the IO queueing
   system if we getpeername/getsockname to identify this occurring.
o) Add an IO queueing system that will make it possible to use lio_listio on
   systems that support it.
o) Make the XCodec encoder and decoder asynchronous.
o) Connection table. Database.
o) HTTP termination and reinitiation good enough to support an HTTP proxy mode.

Ongoing:
o) Add lots of comments.
o) Fix bugs.
o) Audit log levels.
o) Try to remove HALTs and NOTREACHEDs that aren't legitimate.
o) Give better debug information from configuration system.

Maybe:
o) A resolver that's less fragile than the OS-supplied ones.  Mac OS X, at minimum,
   neither keeps a pool of file descriptors nor errors out gracefully when the OS is
   out of them, leading to hangs.
o) Send definitions out-of-band, too, so that QoS and backpressure on one connection
   can't delay other connections.
o) In-path forwarding using BPF and a tiny network stack.
o) Run-length-encoding.
o) Many compression algorithms.
o) Allow chaining codecs.
o) SOCKS IPv6 support.
o) Some decent way to configure Pipelines.
o) Figure out a good name for a Pipeline, since Pipeline seems rubbish.
o) Merge two Pipelines.
o) Convert the SOCKS proxy server to a PipeEndpoint that merges the Pipeline
   that it is connected to with a newly-created one.
